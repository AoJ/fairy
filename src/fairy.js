// Generated by CoffeeScript 1.3.1
(function() {
  var Fairy, Queue, prefix, redis, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  uuid = require('node-uuid');

  redis = require('redis');

  prefix = 'FAIRY';

  exports.connect = function(options) {
    var client;
    if (options == null) {
      options = {};
    }
    client = redis.createClient(options.port, options.host);
    if (options.password != null) {
      client.auth(options.password);
    }
    return new Fairy(client);
  };

  process.on('uncaughtException', function(err) {
    return console.log('Caught exception: ' + err);
  });

  Fairy = (function() {

    Fairy.name = 'Fairy';

    function Fairy(redis) {
      this.redis = redis;
      this.queue_pool = {};
    }

    Fairy.prototype.key = function(key) {
      return "" + prefix + ":" + key;
    };

    Fairy.prototype.queue = function(name) {
      if (this.queue_pool[name]) {
        return this.queue_pool[name];
      }
      this.redis.sadd(this.key('QUEUES'), name);
      return this.queue_pool[name] = new Queue(this.redis, name);
    };

    Fairy.prototype.queues = function(callback) {
      var _this = this;
      return this.redis.smembers(this.key('QUEUES'), function(err, res) {
        return callback(res.map(function(name) {
          return _this.queue(name);
        }));
      });
    };

    Fairy.prototype.statistics = function(callback) {
      if (typeof callback !== 'function') {
        return;
      }
      return this.queues(function(queues) {
        var i, queue, result, total_queues, _i, _len, _results;
        if (!(total_queues = queues.length)) {
          return callback([]);
        }
        result = [];
        _results = [];
        for (i = _i = 0, _len = queues.length; _i < _len; i = ++_i) {
          queue = queues[i];
          _results.push((function(queue, i) {
            return queue.statistics(function(statistics) {
              statistics.name = queue.name;
              result[i] = statistics;
              if (!--total_queues ? callback : void 0) {
                return callback(result);
              }
            });
          })(queue, i));
        }
        return _results;
      });
    };

    return Fairy;

  })();

  Queue = (function() {

    Queue.name = 'Queue';

    function Queue(redis, name) {
      this.redis = redis;
      this.name = name;
      this.reschedule = __bind(this.reschedule, this);

      this._continue_group = __bind(this._continue_group, this);

      this._process = __bind(this._process, this);

      this._poll = __bind(this._poll, this);

      this.regist = __bind(this.regist, this);

      this.enqueue = __bind(this.enqueue, this);

    }

    Queue.prototype.key = function(key) {
      return "" + prefix + ":" + key + ":" + this.name;
    };

    Queue.prototype.polling_interval = 5;

    Queue.prototype.retry_delay = 0.1 * 1000;

    Queue.prototype.retry_limit = 2;

    Queue.prototype.recent_size = 10;

    Queue.prototype.slowest_size = 10;

    Queue.prototype.enqueue = function() {
      var args, callback, multi, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (typeof callback !== 'function') {
        args.push(callback);
        callback = void 0;
      }
      args.push(Date.now());
      multi = this.redis.multi();
      multi.rpush(this.key('SOURCE'), JSON.stringify(args));
      multi.hincrby(this.key('STATISTICS'), 'total', 1);
      multi.sadd(this.key('GROUPS'), args[0]);
      return multi.exec(callback);
    };

    Queue.prototype.regist = function(handler) {
      this.handler = handler;
      return this._poll();
    };

    Queue.prototype._poll = function() {
      var _this = this;
      console.log('polling');
      this.redis.watch(this.key('SOURCE'));
      return this.redis.lindex(this.key('SOURCE'), 0, function(err, res) {
        var multi, task;
        if (res) {
          task = JSON.parse(res);
          multi = _this.redis.multi();
          multi.lpop(_this.key('SOURCE'));
          multi.rpush("" + (_this.key('QUEUED')) + ":" + task[0], res);
          return multi.exec(function(multi_err, multi_res) {
            if (!multi_res || multi_res[1] !== 1) {
              return _this._poll();
            }
            return _this._process(task, true);
          });
        } else {
          _this.redis.unwatch();
          return setTimeout(_this._poll, _this.polling_interval);
        }
      });
    };

    Queue.prototype._process = function(task, is_new_task) {
      var call_handler, errors, processing, retry_count, start_time,
        _this = this;
      start_time = Date.now();
      processing = uuid.v4();
      this.redis.hset(this.key('PROCESSING'), processing, JSON.stringify(__slice.call(task).concat([start_time])));
      retry_count = this.retry_limit;
      errors = [];
      return (call_handler = function() {
        return _this.handler.apply(_this, __slice.call(task.slice(0, -1)).concat([function(err, res) {
          var finish_time, multi, process_time;
          if (err) {
            errors.push(err.message || null);
            switch (err["do"]) {
              case 'block':
                multi = _this.redis.multi();
                multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
                multi.hdel(_this.key('PROCESSING'), processing);
                multi.sadd(_this.key('BLOCKED'), task[0]);
                multi.exec();
                return _this._poll();
              case 'block-after-retry':
                if (retry_count--) {
                  return setTimeout(call_handler, _this.retry_delay);
                }
                multi = _this.redis.multi();
                multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
                multi.hdel(_this.key('PROCESSING'), processing);
                multi.sadd(_this.key('BLOCKED'), task[0]);
                multi.exec();
                return _this._poll();
              default:
                if (retry_count--) {
                  return setTimeout(call_handler, _this.retry_delay);
                }
                multi = _this.redis.multi();
                multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
                multi.hdel(_this.key('PROCESSING'), processing);
                multi.exec();
            }
          } else {
            _this.redis.hdel(_this.key('PROCESSING'), processing);
            finish_time = Date.now();
            process_time = finish_time - start_time;
            _this.redis.hincrby(_this.key('STATISTICS'), 'finished', 1);
            _this.redis.hincrby(_this.key('STATISTICS'), 'total_pending_time', start_time - task[task.length - 1]);
            _this.redis.hincrby(_this.key('STATISTICS'), 'total_processing_time', process_time);
            _this.redis.lpush(_this.key('RECENT'), JSON.stringify(__slice.call(task).concat([finish_time])));
            _this.redis.ltrim(_this.key('RECENT'), 0, _this.recent_size - 1);
            _this.redis.zadd(_this.key('SLOWEST'), process_time, JSON.stringify(task));
            _this.redis.zremrangebyrank(_this.key('SLOWEST'), 0, -_this.slowest_size - 1);
          }
          return _this._continue_group(task[0]);
        }]));
      })();
    };

    Queue.prototype._continue_group = function(group) {
      var multi,
        _this = this;
      this.redis.watch("" + (this.key('QUEUED')) + ":" + group);
      multi = this.redis.multi();
      multi.lpop("" + (this.key('QUEUED')) + ":" + group);
      multi.lindex("" + (this.key('QUEUED')) + ":" + group, 0);
      return multi.exec(function(multi_err, multi_res) {
        if (!multi_res) {
          return _this._continue_group(group);
        }
        if (multi_res[1]) {
          return _this._process(JSON.parse(multi_res[1]), true);
        } else {
          return _this._poll();
        }
      });
    };

    Queue.prototype.reschedule = function(callback) {
      var _this = this;
      this.redis.watch(this.key('FAILED'));
      this.redis.watch(this.key('BLOCKED'));
      return this.failed_tasks(function(tasks) {
        var requeued_tasks;
        requeued_tasks = [];
        requeued_tasks.push.apply(requeued_tasks, tasks.map(function(task) {
          return JSON.stringify(task.slice(0, -2));
        }));
        return _this.blocked_groups(function(groups) {
          var group, start_transaction, total_groups, _i, _len, _ref, _results;
          if (groups.length) {
            (_ref = _this.redis).watch.apply(_ref, groups.map(function(group) {
              return "" + (_this.key('QUEUED')) + ":" + group;
            }));
          }
          start_transaction = function() {
            var multi;
            multi = _this.redis.multi();
            if (requeued_tasks.length) {
              multi.rpush.apply(multi, [_this.key('SOURCE')].concat(__slice.call(requeued_tasks)));
            }
            multi.del(_this.key('FAILED'));
            if (groups.length) {
              multi.del.apply(multi, groups.map(function(group) {
                return "" + (_this.key('QUEUED')) + ":" + group;
              }));
            }
            multi.del(_this.key('BLOCKED'));
            multi.del(_this.key('PROCESSING'));
            return multi.exec(function(multi_err, multi_res) {
              if (multi_res) {
                if (callback) {
                  return callback();
                }
              } else {
                return _this.reschedule(callback);
              }
            });
          };
          if (total_groups = groups.length) {
            _results = [];
            for (_i = 0, _len = groups.length; _i < _len; _i++) {
              group = groups[_i];
              _results.push(_this.redis.lrange("" + (_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                requeued_tasks.push.apply(requeued_tasks, res);
                if (!--total_groups) {
                  return start_transaction();
                }
              }));
            }
            return _results;
          } else {
            return start_transaction();
          }
        });
      });
    };

    Queue.prototype.recently_finished_tasks = function(callback) {
      return this.redis.lrange(this.key('RECENT'), 0, -1, function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.failed_tasks = function(callback) {
      return this.redis.lrange(this.key('FAILED'), 0, -1, function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.blocked_groups = function(callback) {
      return this.redis.smembers(this.key('BLOCKED'), function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.slowest_tasks = function(callback) {
      return this.redis.zrevrange(this.key('SLOWEST'), 0, -1, "WITHSCORES", function(err, res) {
        var i;
        res = res.map(function(entry) {
          return JSON.parse(entry);
        });
        return callback((function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = res.length; _i < _ref; i = _i += 2) {
            _results.push(__slice.call(res[i]).concat([res[i + 1]]));
          }
          return _results;
        })());
      });
    };

    Queue.prototype.processing_tasks = function(callback) {
      return this.redis.hvals(this.key('PROCESSING'), function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.statistics = function(callback) {
      var multi,
        _this = this;
      multi = this.redis.multi();
      multi.scard(this.key('GROUPS'));
      multi.hgetall(this.key('STATISTICS'));
      multi.hlen(this.key('PROCESSING'));
      multi.llen(this.key('FAILED'));
      multi.smembers(this.key('BLOCKED'));
      return multi.exec(function(multi_err, multi_res) {
        var group, multi2, result, statistics, _i, _len, _ref;
        statistics = multi_res[1] || {};
        result = {
          total: {
            groups: multi_res[0],
            tasks: statistics.total || 0
          },
          finished_tasks: statistics.finished || 0,
          average_pending_time: Math.round(statistics.total_pending_time * 100 / statistics.finished) / 100,
          average_processing_time: Math.round(statistics.total_processing_time * 100 / statistics.finished) / 100,
          blocked: {}
        };
        if (!result.finished_tasks) {
          result.average_pending_time = '-';
          result.average_processing_time = '-';
        }
        result.processing_tasks = multi_res[2];
        result.failed_tasks = multi_res[3];
        result.blocked.groups = multi_res[4].length;
        multi2 = _this.redis.multi();
        _ref = multi_res[4];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          multi2.llen("" + (_this.key('QUEUED')) + ":" + group);
        }
        return multi2.exec(function(multi2_err, multi2_res) {
          result.blocked.tasks = multi2_res.reduce((function(a, b) {
            return a + b;
          }), -result.blocked.groups);
          result.pending_tasks = result.total.tasks - result.finished_tasks - result.processing_tasks - result.failed_tasks - result.blocked.tasks;
          return callback(result);
        });
      });
    };

    return Queue;

  })();

}).call(this);
