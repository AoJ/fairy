// Generated by CoffeeScript 1.3.1
(function() {
  var child_processes, exec, fairy, fs, queue, should, task_name, total_groups, total_tasks, total_workers;

  exec = require('child_process').exec;

  fs = require('fs');

  should = require('should');

  fairy = require("..").connect();

  task_name = 'TEST2';

  queue = fairy.queue(task_name);

  total_groups = 10;

  total_tasks = 2000;

  total_workers = require('os').cpus().length;

  child_processes = [];

  describe("Process " + total_tasks + " Tasks of " + total_groups + " Groups by " + total_workers + " Fail-n-Block Workers, Kill and Respawn Periodically", function() {
    it("Should Clear the Queue First", function(done) {
      return queue.clear(function(err, statistics) {
        statistics.total.groups.should.equal(0);
        statistics.total.tasks.should.equal(0);
        return done();
      });
    });
    it("Should Enqueue " + total_tasks + " Tasks Successfully", function(done) {
      var generate, generated, group_sequence, _i, _ref, _results;
      generated = 0;
      group_sequence = (function() {
        _results = [];
        for (var _i = 0, _ref = total_groups - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function() {
        return 0;
      });
      return (generate = function() {
        var group, sequence;
        if (generated++ === total_tasks) {
          return queue.statistics(function(err, statistics) {
            statistics.total.groups.should.equal(total_groups);
            statistics.total.tasks.should.equal(total_tasks);
            return done();
          });
        }
        group = parseInt(Math.random() * total_groups);
        sequence = group_sequence[group]++;
        return queue.enqueue(group, sequence, generate);
      })();
    });
    it("Should All Be Processed on a Interrupt and Respawn Environment", function(done) {
      var exiting;
      exiting = false;
      return exec("rm -f " + __dirname + "/workers/*.dmp", function(err, stdout, stderr) {
        var killed, killone, reschedule, stats, workers_left;
        killed = 0;
        workers_left = total_workers;
        child_processes = [];
        while (--workers_left >= 0) {
          (function(workers_left) {
            var respawn;
            child_processes[workers_left] = exec("coffee " + __dirname + "/workers/fail-and-block.coffee " + task_name);
            respawn = function(workers_left) {
              child_processes[workers_left] = exec("coffee " + __dirname + "/workers/fail-and-block.coffee " + task_name);
              return child_processes[workers_left].on('exit', (function(workers_left) {
                return function() {
                  killed++;
                  if (exiting) {
                    return;
                  }
                  return respawn(workers_left);
                };
              })(workers_left));
            };
            return child_processes[workers_left].on('exit', (function(workers_left) {
              return function() {
                killed++;
                if (exiting) {
                  return;
                }
                return respawn(workers_left);
              };
            })(workers_left));
          })(workers_left);
        }
        (reschedule = function() {
          queue.reschedule(function(err, statistics) {});
          return setTimeout(reschedule, 100);
        })();
        (killone = function() {
          return queue.workers(function(err, workers) {
            var allowed_signals, random_signal, victim_index;
            if (!workers.length) {
              return setTimeout(killone, 100);
            }
            victim_index = parseInt(Math.random() * workers.length);
            allowed_signals = ['SIGINT', 'SIGHUP', 'SIGUSR2'];
            random_signal = function() {
              return allowed_signals[parseInt(Math.random() * allowed_signals.length)];
            };
            process.kill(workers[victim_index].pid, random_signal());
            return setTimeout(killone, 100);
          });
        })();
        return (stats = function() {
          return queue.statistics(function(err, statistics) {
            if (statistics.finished_tasks === total_tasks) {
              return setTimeout(function() {
                return queue.statistics(function(err, statistics) {
                  if (statistics.finished_tasks === total_tasks && statistics.pending_tasks === 0) {
                    exiting = true;
                    console.log(", " + killed + " workers killed, " + statistics.workers + " alive");
                    return done();
                  }
                });
              }, 100);
            } else {
              return setTimeout(stats, 10);
            }
          });
        })();
      });
    });
    it("Should Cleanup Elegantly on Interruption", function(done) {
      return queue.workers(function(err, workers) {
        var allowed_signals, get_statistics, random_signal, worker, _i, _len;
        allowed_signals = ['SIGINT', 'SIGHUP', 'SIGUSR2'];
        random_signal = function() {
          return allowed_signals[parseInt(Math.random() * allowed_signals.length)];
        };
        for (_i = 0, _len = workers.length; _i < _len; _i++) {
          worker = workers[_i];
          process.kill(worker.pid, random_signal());
        }
        return (get_statistics = function() {
          return queue.statistics(function(err, statistics) {
            if (statistics.workers !== 0) {
              return get_statistics();
            }
            return setTimeout(function() {
              return queue.statistics(function(err, statistics) {
                if (statistics.workers === 0) {
                  return done();
                }
              });
            }, 20);
          });
        })();
      });
    });
    return it("Should Dump Incremental Numbers", function(done) {
      var content, group, line, _i, _j, _len, _ref, _ref1;
      for (group = _i = 0, _ref = total_groups - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; group = 0 <= _ref ? ++_i : --_i) {
        _ref1 = fs.readFileSync("" + __dirname + "/workers/" + group + ".dmp").toString().split('\n').slice(0, -1);
        for (line = _j = 0, _len = _ref1.length; _j < _len; line = ++_j) {
          content = _ref1[line];
          console.log(group, content, line);
          content.should.equal("" + line);
        }
      }
      return exec("rm -f " + __dirname + "/workers/*.dmp", done);
    });
  });

}).call(this);
